<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Multiple defining uses of Type Alias Impl Traits - Santiago Pastorino</title><meta name=description content="Disclaimer: this blog post comes from some notes I took meanwhile working on an Rust compiler issue and it&rsquo;s not very polished but I&rsquo;ve decided to publish it anyway.
A bug was reported to the compiler that involves type checking, inference, traits and in particular type alias impl traits (TAIT) with multiple defining uses and some other particular things about them. In this post we are going to explain how the system works as I was investigating this myself in order to fix this issue, what is the issue exactly about and then describe how we&rsquo;ve solved the issue."><meta name=author content="Santiago Pastorino"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Santiago Pastorino","url":"https:\/\/santiagopastorino.com"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/santiagopastorino.com"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/santiagopastorino.com","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/santiagopastorino.com\/2021\/06\/16\/multiple-defining-uses-of-taits\/","name":"Multiple defining uses of type alias impl traits"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Santiago Pastorino"},"headline":"Multiple defining uses of Type Alias Impl Traits","description":"Disclaimer: this blog post comes from some notes I took meanwhile working on an Rust compiler issue and it\u0026rsquo;s not very polished but I\u0026rsquo;ve decided to publish it anyway.\nA bug was reported to the compiler that involves type checking, inference, traits and in particular type alias impl traits (TAIT) with multiple defining uses and some other particular things about them. In this post we are going to explain how the system works as I was investigating this myself in order to fix this issue, what is the issue exactly about and then describe how we\u0026rsquo;ve solved the issue.","inLanguage":"en","wordCount":1334,"datePublished":"0001-01-01T00:00:00","dateModified":"2021-06-16T00:00:00","image":"https:\/\/santiagopastorino.com\/images\/santiago.jpg","keywords":["rust, compiler, taits"],"mainEntityOfPage":"https:\/\/santiagopastorino.com\/2021\/06\/16\/multiple-defining-uses-of-taits\/","publisher":{"@type":"Organization","name":"https:\/\/santiagopastorino.com","logo":{"@type":"ImageObject","url":"https:\/\/santiagopastorino.com\/images\/santiago.jpg","height":60,"width":60}}}</script><meta property="og:title" content="Multiple defining uses of Type Alias Impl Traits"><meta property="og:description" content="Disclaimer: this blog post comes from some notes I took meanwhile working on an Rust compiler issue and it&rsquo;s not very polished but I&rsquo;ve decided to publish it anyway.
A bug was reported to the compiler that involves type checking, inference, traits and in particular type alias impl traits (TAIT) with multiple defining uses and some other particular things about them. In this post we are going to explain how the system works as I was investigating this myself in order to fix this issue, what is the issue exactly about and then describe how we&rsquo;ve solved the issue."><meta property="og:image" content="https://santiagopastorino.com/images/santiago.jpg"><meta property="og:url" content="https://santiagopastorino.com/2021/06/16/multiple-defining-uses-of-taits/"><meta property="og:type" content="website"><meta property="og:site_name" content="Santiago Pastorino"><meta name=twitter:title content="Multiple defining uses of Type Alias Impl Traits"><meta name=twitter:description content="Disclaimer: this blog post comes from some notes I took meanwhile working on an Rust compiler issue and it&rsquo;s not very polished but I&rsquo;ve decided to publish it anyway.
A bug was reported to â€¦"><meta name=twitter:image content="https://santiagopastorino.com/images/santiago.jpg"><meta name=twitter:card content="summary"><meta name=twitter:site content="@spastorino"><meta name=twitter:creator content="@spastorino"><link href=https://santiagopastorino.com/images/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.104.3"><link rel=alternate href=https://santiagopastorino.com/index.xml type=application/rss+xml title="Santiago Pastorino"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://santiagopastorino.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://santiagopastorino.com/css/syntax.css><link rel=stylesheet href=https://santiagopastorino.com/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-89777501-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://santiagopastorino.com>Santiago Pastorino</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Santiago Pastorino" href=https://santiagopastorino.com><img class=avatar-img src=https://santiagopastorino.com/images/santiago.jpg alt="Santiago Pastorino"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Multiple defining uses of Type Alias Impl Traits</h1><span class=post-meta>Posted on June 16, 2021</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Disclaimer: this blog post comes from some notes I took meanwhile
working on an Rust compiler issue and it&rsquo;s not very polished but I&rsquo;ve
decided to publish it anyway.</p><p>A <a href=https://github.com/rust-lang/rust/issues/73481>bug was reported to the
compiler</a> that involves
type checking, inference, traits and in particular type alias impl
traits (TAIT) with multiple defining uses and some other particular
things about them. In this post we are going to explain how the system
works as I was investigating this myself in order to fix this issue,
what is the issue exactly about and then describe how we&rsquo;ve solved the
issue.</p><p>First, let&rsquo;s get started with the code that causes the problem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#![feature(min_type_alias_impl_trait)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span> <span class=nc>X</span><span class=o>&lt;</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=nb>Into</span><span class=o>&lt;&amp;&#39;</span><span class=nb>static</span><span class=w> </span><span class=n>A</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>f</span><span class=o>&lt;</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=o>&#39;</span><span class=nb>static</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=nb>static</span> <span class=nc>A</span><span class=p>,</span><span class=w> </span><span class=n>_b</span>: <span class=nc>B</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=n>X</span><span class=o>&lt;</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>X</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>A</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=o>&lt;</span><span class=n>X</span><span class=o>&lt;</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>&gt;</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nb>Into</span><span class=o>&lt;&amp;</span><span class=nb>String</span><span class=o>&gt;&gt;</span>::<span class=n>into</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[</span><span class=mi>1</span><span class=k>isize</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>],</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>()).</span><span class=mi>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>If you try to run this program using nightly (with one before the fix
landed) you&rsquo;ll get:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[santiago@galago tait_issue (master)]$ cargo run
</span></span><span class=line><span class=cl>   Compiling tait_issue v0.1.0 (/tmp/tait_issue)
</span></span><span class=line><span class=cl>    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
</span></span><span class=line><span class=cl>     Running `target/debug/tait_issue`
</span></span><span class=line><span class=cl>Segmentation fault (core dumped)
</span></span></code></pre></div><p>This program should not compile but it does and when you run it you get
a segfault. So, this is a
<a href=https://en.wikipedia.org/wiki/Soundness>soundness</a> issue in our type
system. We want every program that type checks to be a valid one; but
that is not what happens with this example: the compiler type checks but
the program is invalid.</p><p>Let&rsquo;s see how the compiler type checks this and other simpler programs
in order to get a better understanding of what&rsquo;s going on.</p><h2 id=type-checking-tait-a-simple-example>Type checking TAIT: a simple example</h2><p>Let&rsquo;s type check the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>X</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=nb>Into</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>foo</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>X</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The idea is that <code>impl Into&lt;A></code> in that position &lsquo;desugars&rsquo; into a kind
of &rsquo;existential type&rsquo;, something whose value must be inferred. It is
inferred when there is a &ldquo;defining use&rdquo;, which is basically a use of the
type alias in a context that defines the value of the &ldquo;hidden&rdquo; type.</p><p>For the purposes of type checking, is important to consider that the
following code which our example uses, lives on stdlib &mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>t</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Into</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>U</span>: <span class=nb>From</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>into</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>U</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>U</span>::<span class=n>from</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>So written as program clauses, from stdlib we have:
<code>&lt;T> T: From&lt;T></code>
<code>&lt;T, U> T: Into&lt;U> if U: From&lt;T></code></p><p>Let&rsquo;s type check <code>foo</code>:</p><p>First of all, as we&rsquo;ve said previously we need to convert the return
type, which would be <code>impl Into&lt;T></code> into an existential type &mldr; So our
<code>foo</code> function will look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>foo</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>?</span><span class=n>X</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>and we will have the following clause:
<code>?X: Into&lt;T></code> because <code>X&lt;T></code> was really the return type.</p><p>Type checking <code>foo</code>&rsquo;s body, which is not important for the purposes of
this work, will give us that the type being returned is <code>T</code> because <code>x</code>
is returned and its type is <code>T</code>.
Then, we can deduce the following clause:
<code>T = ?X</code></p><p>Unifying those two clauses we end up with:
<code>T: Into&lt;T></code></p><p>Then, unifying the clause <code>&lt;T, U> T: Into&lt;U> if U: From&lt;T></code> with our
current program clause we have <code>&lt;T> T: Into&lt;T> if T: From&lt;T></code>. So <code>T: Into&lt;T></code> holds if <code>T: From&lt;T></code> holds, and <code>T: From&lt;T></code> holds because
it&rsquo;s one of the clauses that also comes from stdlib.</p><p>So <code>foo</code> signature type checks and <code>?X</code> is <code>T</code>.</p><p>What happens after that is that we use the inferred <code>?X</code> value <code>T</code>, to
figure out what&rsquo;s the real type of <code>X&lt;A></code>, which in our case we conclude
that it&rsquo;s <code>T</code>.</p><h2 id=type-alias-impl-traits-rules>Type Alias Impl Traits Rules</h2><p>Let&rsquo;s consider the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>X</span><span class=o>&lt;</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>In this case, what would be the &ldquo;hidden&rdquo; type?, it could either be <code>A</code>
or <code>B</code>, those are types that the inference context can use to define the
actual types.</p><p>If the defining use is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>foo</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>Z</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=nc>T</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=nc>Z</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>X</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>Z</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>the &ldquo;hidden&rdquo; type would be <code>A</code>. Type alias can be treated as type <code>X&lt;A, B> = A</code>.</p><p>If the defining use is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>foo</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>Z</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=nc>T</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=nc>Z</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>X</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>Z</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>the &ldquo;hidden&rdquo; type would be <code>B</code>. Type alias can be treated as type <code>X&lt;A, B> = B</code>.</p><p>If the defining use is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>foo</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>X</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>that would be ambiguous, it could either be <code>A</code>, <code>B</code> or a combination of both.</p><p>So, the code is rejected by the compiler.</p><p>There&rsquo;s a similar problem with the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>X</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>foo</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>X</span><span class=o>&lt;</span><span class=kt>u32</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=mi>22_</span><span class=k>u32</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>in this case, the type of <code>X&lt;A></code> could either be <code>u32</code> or just <code>A</code>.
So, the compiler again rejects the code.</p><p>So in order to avoid this ambiguity, when we have a &ldquo;defining use&rdquo; of a
TAIT, the generic arguments to that TAIT must all be unique generic
arguments from the surrounding scope.</p><p>In our previous examples we saw that we used <code>u32</code> which is not generic
so the compiler rejected the code and in the other example we&rsquo;ve used
<code>&lt;T, T></code> which is generic but the generic arguments are not unique, so
the compiler rejected it too.</p><h2 id=back-to-the-reported-issue>Back to the reported issue</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>X</span><span class=o>&lt;</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=nb>Into</span><span class=o>&lt;&amp;&#39;</span><span class=nb>static</span><span class=w> </span><span class=n>A</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>f</span><span class=o>&lt;</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=o>&#39;</span><span class=nb>static</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=nb>static</span> <span class=nc>A</span><span class=p>,</span><span class=w> </span><span class=n>_b</span>: <span class=nc>B</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=n>X</span><span class=o>&lt;</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>X</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>A</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>As we see in this example, there are two defining uses of <code>X</code>, <code>X&lt;A, B></code>
and <code>X&lt;B, A></code> and each of those uses follow the rules. Both reference
only generic parameters from <code>f</code> and are both unique. The bug happens
because we do not recognize that there are two different uses of <code>X</code>.
What we do today is that we create just one inference variable <code>?X</code> for
both uses and we ignore one of the uses. What we should do is treat
each use separately, by creating two inference variables, let&rsquo;s say
<code>?X1</code> and <code>?X2</code>.</p><p>In the following post we&rsquo;ll see how we&rsquo;ve implemented this change that
allowed the compiler to create different inference variable for each
different defining use.</p><h2 id=implementing-the-idea-in-the-compiler>Implementing the idea in the compiler</h2><p>I&rsquo;ve placed a <a href=https://github.com/rust-lang/rust/pull/86118>PR #86118</a> which implements the previously discussed idea.</p><p>During type check, for each <strong>defining use</strong> of a TAIT, we replace those
uses with inference variables in
<a href=https://github.com/rust-lang/rust/blob/835150e7/compiler/rustc_trait_selection/src/opaque_types.rs#L153-L185><code>instantiate_opaque_types</code></a>.
Following down the path taken by <code>instantiate_opaque_types</code>, we will be
calling
<a href=https://github.com/rust-lang/rust/blob/835150e7/compiler/rustc_trait_selection/src/opaque_types.rs#L1029-L1035><code>fold_opaque_ty</code></a>
for each opaque type that shows up meanwhile type checking. That&rsquo;s going
to replace each of the opaque types with an inference variable.</p><p>The problem we&rsquo;ve is due <a href=https://github.com/rust-lang/rust/blob/835150e7/compiler/rustc_trait_selection/src/opaque_types.rs#L1043>this
line</a>.
Using <code>def_id</code> as the key, we would be getting the same inference
variable for both <code>X&lt;A, B></code> and <code>X&lt;B, A></code> defining uses. So, as stated
previously we need to use <code>def_id</code> and <code>substs</code> as part of the key in
order to differentiate things like <code>X&lt;A, B></code> from <code>X&lt;B, A></code>.</p><p>The first naive thing to try to do is to change
<a href=https://github.com/rust-lang/rust/blob/835150e7/compiler/rustc_trait_selection/src/opaque_types.rs#L19>OpaqueTypeMap</a>
to be, instead of a <code>DefId</code> -> <code>OpaqueTypeDecl</code> map, be just <code>DefId, SubstsRef</code> -> <code>OpaqueTypeDecl</code> map. I&rsquo;ve tried that path and it gives a
lot of troubles because the new key pair needs to implement <code>HashStable</code>
and stuff like that, so I&rsquo;m not taking this path in the blog post :).</p><p>What we&rsquo;ve done instead is to implement a <code>VecMap</code> structure which will
sort the previous issue, but also, we got rid of <code>HashMap</code> which was an
overkill for our use case. This &ldquo;map&rdquo; would not have a lot of elements
in it.</p><p>Considering all this, please <a href=https://github.com/rust-lang/rust/pull/86118>check out the provided
PR</a>, which is already
merged. Most of the changes in the PR that are not explained in this
post, are fallouts produced by this mentioned key change, where we
substituted <code>DefId</code> as the key of the map with <code>DefId</code> and <code>SubstsRef</code>
and also I&rsquo;ve removed <code>SubstsRef</code> from the produced values of
<code>OpaqueTypeMap</code> given that <code>SubstsRef</code> is now part of the key.</p><div class=blog-tags><a href=https://santiagopastorino.com/tags/rust/>rust</a>&nbsp;
<a href=https://santiagopastorino.com/tags/compiler/>compiler</a>&nbsp;
<a href=https://santiagopastorino.com/tags/taits/>taits</a>&nbsp;</div><h4 class=see-also>See also</h4><ul><li><a href=/2019/12/18/bisecting-rust-compiler/>Bisecting Rust Compiler Regressions with cargo-bisect-rustc</a></li><li><a href=/2018/01/08/how-to-use-rust-non-lexical-lifetimes-on-nightly/>How to Use Rust Non Lexical Lifetimes on Nightly</a></li><li><a href=/2017/01/03/rust-marketing-pitch/>Rust Marketing Pitch</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://santiagopastorino.com/2019/12/18/bisecting-rust-compiler/ data-toggle=tooltip data-placement=top title="Bisecting Rust Compiler Regressions with cargo-bisect-rustc">&larr; Previous Post</a></li></ul></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:spastorino@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/spastorino title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/spastorino title=Twitter><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://santiagopastorino.com>Santiago Pastorino</a>
&nbsp;&bull;&nbsp;&copy;
2021</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.104.3</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script>
<script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script>
<script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script>
<script src=https://santiagopastorino.com/js/main.js></script><script>renderMathInElement(document.body)</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://santiagopastorino.com/js/load-photoswipe.js></script></body></html>