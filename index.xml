<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Santiago Pastorino</title><link>https://santiagopastorino.com/</link><description>Recent content on Santiago Pastorino</description><generator>Hugo -- gohugo.io</generator><managingEditor>spastorino@gmail.com (Santiago Pastorino)</managingEditor><webMaster>spastorino@gmail.com (Santiago Pastorino)</webMaster><lastBuildDate>Thu, 20 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://santiagopastorino.com/index.xml" rel="self" type="application/rss+xml"/><item><title>RPITs, RPITITs and AFITs and their relationship</title><link>https://santiagopastorino.com/2022/10/20/what-rpits-rpitits-and-afits-and-their-relationship/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><author>spastorino@gmail.com (Santiago Pastorino)</author><guid>https://santiagopastorino.com/2022/10/20/what-rpits-rpitits-and-afits-and-their-relationship/</guid><description>This is the first blog post as part of a series of blog posts that will try to explain how impl trait in return position inside and outside traits and async fns in traits works. This first post explains just the concepts with examples. In the following ones we would be explaining more of the internal details.
What is an RPIT? RPIT stands for Return Position Impl Trait. It&amp;rsquo;s basically an opaque return type for a function, defined as &amp;ldquo;something&amp;rdquo; that implements the mentioned trait.</description></item><item><title>Multiple defining uses of Type Alias Impl Traits</title><link>https://santiagopastorino.com/2021/06/16/multiple-defining-uses-of-taits/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><author>spastorino@gmail.com (Santiago Pastorino)</author><guid>https://santiagopastorino.com/2021/06/16/multiple-defining-uses-of-taits/</guid><description>Disclaimer: this blog post comes from some notes I took meanwhile working on an Rust compiler issue and it&amp;rsquo;s not very polished but I&amp;rsquo;ve decided to publish it anyway.
A bug was reported to the compiler that involves type checking, inference, traits and in particular type alias impl traits (TAIT) with multiple defining uses and some other particular things about them. In this post we are going to explain how the system works as I was investigating this myself in order to fix this issue, what is the issue exactly about and then describe how we&amp;rsquo;ve solved the issue.</description></item><item><title>Bisecting Rust Compiler Regressions with cargo-bisect-rustc</title><link>https://santiagopastorino.com/2019/12/18/bisecting-rust-compiler/</link><pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate><author>spastorino@gmail.com (Santiago Pastorino)</author><guid>https://santiagopastorino.com/2019/12/18/bisecting-rust-compiler/</guid><description>This article is cross-posted from Inside Rust blog.
Let&amp;rsquo;s say that you&amp;rsquo;ve just updated the Rust compiler version and have tried to compile your application and see a failure that wasn&amp;rsquo;t there before. That&amp;rsquo;s likely due to a regression in the compiler. We&amp;rsquo;ve just released cargo-bisect-rustc, a tool that makes it super easy to find exactly when the regression happened.
cargo-bisect-rustc automatically downloads rustc artifacts and tests them against a project you provide until it finds the regression.</description></item><item><title>How to Use Rust Non Lexical Lifetimes on Nightly</title><link>https://santiagopastorino.com/2018/01/08/how-to-use-rust-non-lexical-lifetimes-on-nightly/</link><pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate><author>spastorino@gmail.com (Santiago Pastorino)</author><guid>https://santiagopastorino.com/2018/01/08/how-to-use-rust-non-lexical-lifetimes-on-nightly/</guid><description>&lt;p>&lt;a href="https://twitter.com/nikomatsakis">Niko Matsakis&lt;/a>, &lt;a href="https://twitter.com/Nashenas88">Paul
Faria&lt;/a> and
&lt;a href="https://twitter.com/spastorino">I&lt;/a> have been working on Non Lexical
Lifetimes (NLL) during the &lt;a href="https://internals.rust-lang.org/t/announcing-the-impl-period-sep-18-dec-17/5676">impl
period&lt;/a>.
The work has landed on master and you can use it right now by installing
Rust nightly.&lt;/p></description></item><item><title>Rust Marketing Pitch</title><link>https://santiagopastorino.com/2017/01/03/rust-marketing-pitch/</link><pubDate>Tue, 03 Jan 2017 00:00:00 +0000</pubDate><author>spastorino@gmail.com (Santiago Pastorino)</author><guid>https://santiagopastorino.com/2017/01/03/rust-marketing-pitch/</guid><description>&lt;p>There’s been a very interesting and constructive debate about how to
market &lt;em>Rust&lt;/em>, mainly motivated by &lt;a href="http://words.stevekblanik.com/rust-is-more-than-safety">Steve Klabnik’s blog
post&lt;/a>, which was
later followed by &lt;a href="http://graydon2.dreamwidth.org/247406.html">Graydon
Hoare’s&lt;/a>, &lt;a href="https://thefeedbackloop.xyz/safety-is-rusts-fireflower/">Dave
Herman’s&lt;/a>, and
others writings. I consider both &lt;em>Mozilla&lt;/em> and the &lt;em>Rust&lt;/em> community are
doing an excellent marketing job, as I’ve never seen any other
language/community doing so, but there’s always room for more
improvements.&lt;/p></description></item><item><title>About me</title><link>https://santiagopastorino.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>spastorino@gmail.com (Santiago Pastorino)</author><guid>https://santiagopastorino.com/about/</guid><description>Welcome to my blog. I&amp;rsquo;m Santiago Pastorino, Co-founder of WyeWorks, a software development consulting firm. I&amp;rsquo;m Rust compiler team contributor, do Rust consultancy and give Rust courses and trainings. I also organize Rust Latam and I&amp;rsquo;m Rails core team alumni.</description></item></channel></rss>